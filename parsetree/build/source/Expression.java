/* autogenerated by Processing revision 1279 on 2022-05-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Expression extends PApplet {

ExpressionTree fir;
String prefix = "+ - * 80.0 66.0 36.0 * 58.0 - 36.0 51.0";
String prefix2 = "(+ (- (* 80.0 66.0) 36.0) (* 58.0 (- 36.0 51.0)))";
String infix = "((22.0 - (43.0 + (52.0 - 62.0))) + (4.0 * 72.0))";

 public void setup() {
  /* size commented out by preprocessor */;
  background(200);

  //fir = new ExpressionTree(400, 20, 4);
  fir = new ExpressionTree(400, 20, infix, ExpressionTree.IN);
  //fir = new ExpressionTree(400, 20, prefix2, ExpressionTree.PRE);

  fir.display();
  fir.evaluate();

  println(fir.traverse(ExpressionTree.IN));
  println(fir.traverse(ExpressionTree.PRE));
  println(fir.traverse(ExpressionTree.POST));


  println(expressionToList(infix));
  println(expressionToList(prefix));
}//setup

 public void draw() {
  background(200);
  fir.display();
}//draw

 public void keyPressed() {
  if (key == 'r') {
    fir = new ExpressionTree(400, 20, 5);
    println(fir.traverse(ExpressionTree.IN));
  }
  else if (key == 'i') {
    fir = new ExpressionTree(400, 20, infix, ExpressionTree.IN);
  }
  else if (key == 'p') {
    fir = new ExpressionTree(400, 20, prefix, ExpressionTree.PRE);
  }
  fir.evaluate();
}//keyPressed


 public void mousePressed() {
  ExpressionTreeNode selected = fir.findNode(PApplet.parseInt(mouseX), PApplet.parseInt(mouseY));
  if (selected != null) {
    selected.flipNode();
    fir.evaluate();
    fir.display();
    //saveFrame("l04_exp-tree-nan.png");
  }
}//mousePressed

 public StringList expressionToList(String expression) {
  String[] ts = expression.split(" ");
  StringList tokens = new StringList();
  String parens = "";

  for (int i=0; i < ts.length; i++) {
    while ( ts[i].charAt(0) == '(' ) {
      tokens.append(ts[i].charAt(0)+"");
      ts[i] = ts[i].substring(1);
    }//deal with (

    while ( ts[i].charAt(ts[i].length()-1) == ')') {
      parens+= ")";
      ts[i] = ts[i].substring(0, ts[i].length()-1);
    }//remove & store all )

    tokens.append(ts[i]);

    while (parens.length() != 0) {
      tokens.append(parens.charAt(0) + "");
      parens = parens.substring(1);
    }//add back the )
  }
  return tokens;
}//expressionToList
class ExpressionTree {

  static final int Y_SPACE = 75;
  static final int PRE = 0;
  static final int POST = 1;
  static final int IN = 2;
  static final int MAX_DEPTH = 5;

  ExpressionTreeNode root;
  int totalLevels;

  ExpressionTree(int x, int y, int numLevels) {
    totalLevels = numLevels;
    root = makeTree(x, y, numLevels);
    populateTree(root);
  }
   public ExpressionTreeNode makeTree(int x, int y, int numLevels) {
    if (numLevels == 0) {
      return null;
    }

    ExpressionTreeNode newNode = new ExpressionTreeNode(x, y, 0, 0);

    float xoffset = width / (pow(2, totalLevels - numLevels+2));
    int leftX = PApplet.parseInt(x + xoffset * -1);
    int rightX = PApplet.parseInt(x + xoffset);
    int newY = y + Y_SPACE;

    if ( random(totalLevels) >= (totalLevels - numLevels)) {
      newNode.left = makeTree(leftX, newY, numLevels-1);
      newNode.right = makeTree(rightX, newY, numLevels-1);
    }
    return newNode;
  }//makeTree

   public void populateTree(ExpressionTreeNode current) {
    if (current.left == null && current.right == null) {
      current.type = ExpressionTreeNode.VAL;
      current.value = PApplet.parseInt(random(100));
      //current.value = 0;
    }
    else {
      current.type = PApplet.parseInt(random(4));
      populateTree(current.left);
      populateTree(current.right);
    }
  }//populateTree

  ExpressionTree(int x, int y, String expression, int expType) {
    totalLevels = MAX_DEPTH;
    StringList tokens = expressionToList(expression);
    if (expType == PRE) {
      root = makeTreePrefix(x, y, tokens, totalLevels);
    }
    else {
      root = makeTreeInfix(x, y, tokens, totalLevels);
    }
  }//
   public ExpressionTreeNode makeTreePrefix(int x, int y, StringList tokens, int numLevels) {
    if ( tokens.size() == 0 ) {
      return null;
    }//no more nodes!

    String token = tokens.remove(0);
    if (token.equals("(") || token.equals(")")) {
      return makeTreePrefix(x, y, tokens, numLevels);
    }

    ExpressionTreeNode newNode = new ExpressionTreeNode(x, y, token);

    if (newNode.type == ExpressionTreeNode.VAL) {
      return newNode;
    }
    else {
      float xoffset = width / (pow(2, totalLevels - numLevels+2));
      int leftX = PApplet.parseInt(x + xoffset * -1);
      int rightX = PApplet.parseInt(x + xoffset);
      int newY = y + Y_SPACE;

      newNode.left = makeTreePrefix(leftX, newY, tokens, numLevels-1);
      newNode.right = makeTreePrefix(rightX, newY, tokens, numLevels-1);

      return newNode;
    }//operator, make a node
  }//convertToTree


   public ExpressionTreeNode makeTreeInfix(int x, int y, StringList tokens, int numLevels) {
    if ( tokens.size() == 0 ) {
      return null;
    }//no more nodes!

    ExpressionTreeNode newNode = new ExpressionTreeNode(x, y, 0, 0);
    float xoffset = width / (pow(2, totalLevels - numLevels+2));
    int leftX = PApplet.parseInt(x + xoffset * -1);
    int rightX = PApplet.parseInt(x + xoffset);
    int newY = y + Y_SPACE;

    String token = tokens.remove(0);
    float tokenValue = PApplet.parseFloat(token);

    if (token.equals("(")) {
      newNode.left = makeTreeInfix(leftX, newY, tokens, numLevels-1);
      token = tokens.remove(0); //operation
      newNode.type = newNode.nodeTypeFromString(token);
      newNode.right = makeTreeInfix(rightX, newY, tokens, numLevels-1);
      tokens.remove(0); //closing parentheses
    }
    else {
      newNode.type = ExpressionTreeNode.VAL;
      newNode.value = tokenValue;
    }//number
    return newNode;
  }

   public void display(ExpressionTreeNode current) {
    if (current != null) {
      current.display();
      display(current.left);
      display(current.right);
    }
  }//display
   public void display() {
    display(root);
  }//display wrapper

   public String traverse(int type) {
    if (type == PRE)
      return preOrder(root);
    else if (type == POST)
      return postOrder(root);
    else if (type == IN)
      return inOrder(root);
    return "";
  }//traverse wrapper

   public String inOrder(ExpressionTreeNode current) {
    String s = "";
    if (current != null) {
      s = current.getDisplayString();
      if (current.type == ExpressionTreeNode.VAL) {
        return s;
      }
      else {
        return "(" + inOrder(current.left) + " " + s + " " +  inOrder(current.right) + ")";
      }
    }
    return s;
  }//inOrder

   public String preOrder(ExpressionTreeNode current) {
    String s = "";
    if (current != null) {
      s = current.getDisplayString();
      if (current.type == ExpressionTreeNode.VAL) {
        return s;
      }
      else {
        return "(" + s + " " + preOrder(current.left) + " " + preOrder(current.right) + ")";
      }
    }
    return "";
  }

   public String postOrder(ExpressionTreeNode current) {
    String s = "";
    if (current != null) {
      s = current.getDisplayString();
      if (current.type == ExpressionTreeNode.VAL) {
        return s;
      }
      else {
        return "(" + postOrder(current.left) + " " + postOrder(current.right) + " " + s + ")";
      }
    }
    return s;
  }

   public float evaluate(ExpressionTreeNode current) {
    if (current.type == ExpressionTreeNode.VAL) {
      return current.value;
    }
    else {
      float leftValue = evaluate(current.left);
      float rightValue = evaluate(current.right);
      if (current.type == ExpressionTreeNode.PLUS) {
        current.value = leftValue + rightValue;
      }
      else if (current.type == ExpressionTreeNode.MINUS) {
        current.value = leftValue - rightValue;
      }
      else if (current.type == ExpressionTreeNode.TIMES) {
        current.value = leftValue * rightValue;
      }
      else if (current.type == ExpressionTreeNode.DIVIDE) {
        current.value = leftValue / rightValue;
      }
      if (Float.isInfinite(current.value) || Float.isNaN(current.value)) {
        current.c = color(255, 0, 0);
        return Float.NaN;
      }
      else {
        current.c = ExpressionTreeNode.DEFAULT_C;
      }
      return current.value;
    }
  }//evaluate
   public void evaluate() {
    evaluate(root);
  }//evaluate wrapper

  public ExpressionTreeNode findNode(ExpressionTreeNode current, int x, int y) {
   if (current == null) {
     return null;
   }
   else if (current.contains(x, y)) {
     return current;
   }
   else if (x > current.position.x) {
     return findNode(current.right, x, y);
   }
   else {
     return findNode(current.left, x, y);
   }
 }//findNode
  public ExpressionTreeNode findNode(int x, int y) {
    return findNode(root, x, y);
 }//findNode wrapper




}//ExpressionTree
class ExpressionTreeNode {

  static final int PART_SIZE = 40;
  static final int DEFAULT_C = 0xFFF08C28;

  static final int PLUS = 0;
  static final int MINUS = 1;
  static final int TIMES = 2;
  static final int DIVIDE = 3;
  static final int VAL = 4;



  PVector position;
  int psize;
  int c;

  float value;
  int type;

  ExpressionTreeNode left;
  ExpressionTreeNode right;

  ExpressionTreeNode(int x, int y, int t, float v) {
    position = new PVector(x, y);
    psize = PART_SIZE;
    left = null;
    right = null;
    c = color(240, 140, 40);
    type = t;
    value = v;
  }//float constructor

  ExpressionTreeNode(int x, int y, String token) {
    this(x, y, 4, 0);
    float tokenValue = PApplet.parseFloat(token);

    if (Float.isNaN(tokenValue)) {
      type = nodeTypeFromString(token);
    }//operation node
    else {
      value = tokenValue;
    }//value Node
  }//String constructor

   public int nodeTypeFromString(String token) {
    int op = ExpressionTreeNode.PLUS;
    if (token.equals("-")) {
      op = ExpressionTreeNode.MINUS;
    }
    else if (token.equals("*")) {
      op = ExpressionTreeNode.TIMES;
    }
    else if (token.equals("/")) {
      op = ExpressionTreeNode.DIVIDE;
    }
    return op;
  }//nodeTypeFromString

   public String getDisplayString() {
    String s = str(value);
    if (type != VAL) {
      if (type == PLUS) {
        s = "+";
      }
      else if (type == MINUS) {
        s = "-";
      }
      else if (type == TIMES) {
        s = "*";
      }
      else if (type == DIVIDE) {
        s = "/";
      }
    }
    return s;
  }//getDisplayString

   public boolean contains(int x, int y) {
    float d = position.dist(new PVector(x, y));
    return d <= psize;
  }//contains

   public void flipNode() {
    if (type != VAL) {
      type = (type + 1) % 4;
    }
    else {
      if (value == 0) {
        value = PApplet.parseInt(random(100));
      }
      else {
        value = 0;
      }
    }
  }//filpNode

   public void display() {
    if (left != null) {
      stroke(40, 200, 190);
      line(position.x, position.y, left.position.x, left.position.y);
    }
    if (right != null) {
      stroke(210, 50, 150);
      line(position.x, position.y, right.position.x, right.position.y);
    }
    noStroke();
    fill(c);
    circle(position.x, position.y, psize);
    fill(0);
    textSize(15);
    textAlign(CENTER, TOP);
    text(value, position.x, position.y);
    if (type != VAL) {
      textAlign(CENTER, BASELINE);
      text(getDisplayString(), position.x, position.y);
    }
  }//display

}//Orb


  public void settings() { size(800, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Expression" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
